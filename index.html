<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>NHANES Helper</title>
        <link rel="icon" type="image/x-icon" href="favicon.ico">
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <svg id="plot">
            <text id="title"></text>
            <text id="x-label"></text>
            <text id="y-label"></text>
            <g id="canvas">
                <g id="points"></g>
                <path id="trendline"></path>
                <path id="confidence-interval"></path>
            </g>
            <g id="x-axis"></g>
            <g id="y-axis"></g>
        </svg>
        
        <form id="settings">
            <fieldset>
                <legend>Settings</legend>
                <label for="x-variables">X Variable:</label>
                <select name="x-variables" id="x-variables"></select>
                <br>
                <label for="y-variables">Y Variable:</label>
                <select name="y-variables" id="y-variables"></select>
                <br>
                <button type="button" id="plot-button">Plot</button>
            </fieldset>
        </form>

        <div id="properties">
            <h1></h1>
        </div>

        <div id="lookup">
            <h1></h1>
        </div>

        <script type="module">
            import * as d3 from "https://esm.sh/d3";
            import * as d3Regression from "https://esm.sh/d3-regression";

            // Get margins
            const rootStyle = getComputedStyle(document.documentElement);
            const plotMarginTop = parseInt(rootStyle.getPropertyValue("--plot-margin-top"));
            const plotMarginRight = parseInt(rootStyle.getPropertyValue("--plot-margin-right"));
            const plotMarginBottom = parseInt(rootStyle.getPropertyValue("--plot-margin-bottom"));
            const plotMarginLeft = parseInt(rootStyle.getPropertyValue("--plot-margin-left"));
            
            // Read data synchronously
            const data = await d3.csv("merged.csv");

            // Setup dropdown options
            const fileNames = {};
            Object.keys(data[0]).forEach(function(col) {
                const parts = col.split("|");
                const fileName = parts[0];
                const variableName = parts[1];

                if (fileNames[fileName] === undefined) {
                    fileNames[fileName] = [];
                }
                fileNames[fileName].push(variableName);
            });
            
            function setupVariableDropdown(selectSelector) {
                d3.select(selectSelector)
                    .selectAll("optgroup")
                    .data(Object.entries(fileNames))
                    .join("optgroup")
                    .attr("label", d => d[0])
                    .selectAll("option")
                    .data(d =>
                        d[1].map(
                            v => ({
                                fileName: d[0],
                                variableName: v
                            })
                        )
                    )
                    .join("option")
                    .attr("value", d => `${d.fileName}|${d.variableName}`)
                    .text(d => d.variableName);
            }
            setupVariableDropdown("#x-variables")
            setupVariableDropdown("#y-variables")

            // Initialize dropdown defaults
            d3.select("#x-variables").property("value", "Demographic Variables and Sample Weights|Age in years at screening");
            d3.select("#y-variables").property("value", "Blood Pressure - Oscillometric Measurements|Pulse - 1st oscillometric reading");

            // Perform the data plot with given options
            function plot() {
                // Get width and height
                const width = d3.select("#plot").node().getBoundingClientRect().width;
                const height = d3.select("#plot").node().getBoundingClientRect().height;

                // Read selected x and y variables
                const xCol = d3.select("#x-variables").property("value");
                const yCol = d3.select("#y-variables").property("value");

                // Set title and axis labels
                d3.select("#title").text(`${yCol.split("|")[1]} vs ${xCol.split("|")[1]}`);
                d3.select("#x-label").text(xCol.split("|")[1]);
                d3.select("#y-label").text(yCol.split("|")[1]);

                // Get cleaned version of data
                const cleanData = data.filter(d =>
                    !isNaN(parseInt(d[xCol])) &&
                    !isNaN(parseInt(d[yCol]))
                );
                // Need to actually parse the ints, and make a new table that has just two cols
                // This will make bootstrapping simpler
                
                // Setup x-axis
                const scaleX = d3.scaleLinear()
                    .domain(d3.extent(cleanData, function(d) {
                        return parseInt(d[xCol]);
                    }))
                    .range([0, width - plotMarginLeft - plotMarginRight])
                    .nice();
                const axisXFunc = d3.axisBottom(scaleX);
                d3.select("#x-axis")
                    .transition()
                    .duration(500)
                    .call(axisXFunc);
                
                // Setup y-axis
                const scaleY = d3.scaleLinear()
                    .domain(d3.extent(cleanData, function(d) {
                        return parseInt(d[yCol]);
                    }))
                    .range([height - plotMarginTop - plotMarginBottom, 0])
                    .nice();
                const axisYFunc = d3.axisLeft(scaleY);
                d3.select("#y-axis")
                    .transition()
                    .duration(500)
                    .call(axisYFunc);
                
                // Plot points
                d3.select("#points")
                    .selectAll("circle")
                    .data(cleanData, d => d["Sequence Number|Sequence Number"])
                    .join("circle")
                    .on("click", function(e, d) {
                        console.log(d)
                    })
                    .transition()
                    .duration(500)
                    .attr("r", 2)
                    .attr("opacity", 0.5)
                    .attr("cx", function(d) {
                        return scaleX(parseInt(d[xCol]))
                    })
                    .attr("cy", function(d) {
                        return scaleY(parseInt(d[yCol]))
                    });
                
                // Create trendline
                const regressionGenerator = d3Regression.regressionLoess()
                    .x(d => d[xCol])
                    .y(d => d[yCol])
                    .bandwidth(0.3);
                d3.select("#trendline")
                    .datum(regressionGenerator(cleanData))
                    .transition()
                    .duration(500)
                    .attr("d", d3.line()
                        .x(d => scaleX(d[0]))
                        .y(d => scaleY(d[1]))
                    );

                // Create confidence intervals
                
            }
            
            // Perform an initial plot
            plot();

            // Setup plot button click event
            d3.select("#plot-button")
                .on("click", plot);
            // Plot when plot size is changed
            new ResizeObserver(() => plot()).observe(document.getElementById("plot"));
        </script>
    </body>
</html>
